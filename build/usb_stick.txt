; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\build\usb_stick.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\usb_stick.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\driver -I.\usblib -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C1290NCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DTM4C1290NCZAD --omf_browse=.\build\usb_stick.crf Application\usb_stick.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  usb_send_msg PROC
;;;310    
;;;311    void usb_send_msg(umsg_type type)
000000  b538              PUSH     {r3-r5,lr}
;;;312    {
000002  4604              MOV      r4,r0
;;;313    	 usb_msg_t msg;
;;;314    
;;;315       msg.msg = type;
000004  9400              STR      r4,[sp,#0]
;;;316    	
;;;317    	 xQueueSend(gUsbQueue, &msg, portMAX_DELAY);
000006  2300              MOVS     r3,#0
000008  1e5a              SUBS     r2,r3,#1
00000a  4669              MOV      r1,sp
00000c  485e              LDR      r0,|L1.392|
00000e  6800              LDR      r0,[r0,#0]  ; gUsbQueue
000010  f7fffffe          BL       xQueueGenericSend
;;;318    }
000014  bd38              POP      {r3-r5,pc}
;;;319    
                          ENDP

                  MSCCallback PROC
;;;113    static void
;;;114    MSCCallback(tUSBHMSCInstance *psMSCInstance, uint32_t ui32Event, void *pvData)
000016  b570              PUSH     {r4-r6,lr}
;;;115    {
000018  4605              MOV      r5,r0
00001a  460c              MOV      r4,r1
00001c  4616              MOV      r6,r2
;;;116        //
;;;117        // Determine the event.
;;;118        //
;;;119        switch(ui32Event)
00001e  2c01              CMP      r4,#1
000020  d002              BEQ      |L1.40|
000022  2c02              CMP      r4,#2
000024  d10a              BNE      |L1.60|
000026  e005              B        |L1.52|
                  |L1.40|
;;;120        {
;;;121            //
;;;122            // Called when the device driver has successfully enumerated an MSC
;;;123            // device.
;;;124            //
;;;125            case MSC_EVENT_OPEN:
;;;126            {
;;;127                //
;;;128                // Proceed to the enumeration state.
;;;129                //
;;;130                g_eState = STATE_DEVICE_ENUM;
000028  2001              MOVS     r0,#1
00002a  4958              LDR      r1,|L1.396|
00002c  7008              STRB     r0,[r1,#0]
;;;131    					
;;;132    					  usb_send_msg(USB_STICK_READY);
00002e  f7fffffe          BL       usb_send_msg
;;;133    					
;;;134                break;
000032  e004              B        |L1.62|
                  |L1.52|
;;;135            }
;;;136    
;;;137            //
;;;138            // Called when the device driver has been unloaded due to error or
;;;139            // the device is no longer present.
;;;140            //
;;;141            case MSC_EVENT_CLOSE:
;;;142            {
;;;143                //
;;;144                // Go back to the "no device" state and wait for a new connection.
;;;145                //
;;;146                g_eState = STATE_NO_DEVICE;
000034  2000              MOVS     r0,#0
000036  4955              LDR      r1,|L1.396|
000038  7008              STRB     r0,[r1,#0]
;;;147                break;
00003a  e000              B        |L1.62|
                  |L1.60|
;;;148            }
;;;149    
;;;150            default:
;;;151            {
;;;152                break;
00003c  bf00              NOP      
                  |L1.62|
00003e  bf00              NOP                            ;134
;;;153            }
;;;154        }
;;;155    }
000040  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP

                  ConfigureUSBInterface PROC
;;;166    //*****************************************************************************
;;;167    void ConfigureUSBInterface(void)
000042  b510              PUSH     {r4,lr}
;;;168    {
;;;169        //
;;;170        // Enable the uDMA controller and set up the control table base.
;;;171        // This is required by usblib.
;;;172        //
;;;173        SysCtlPeripheralEnable(SYSCTL_PERIPH_UDMA);
000044  4852              LDR      r0,|L1.400|
000046  f7fffffe          BL       SysCtlPeripheralEnable
;;;174        SysCtlDelay(80);
00004a  2050              MOVS     r0,#0x50
00004c  f7fffffe          BL       SysCtlDelay
;;;175        uDMAEnable();
000050  f7fffffe          BL       uDMAEnable
;;;176        uDMAControlBaseSet(g_sDMAControlTable);
000054  484f              LDR      r0,|L1.404|
000056  f7fffffe          BL       uDMAControlBaseSet
;;;177    
;;;178        //
;;;179        // Enable the USB controller.
;;;180        //
;;;181        SysCtlPeripheralEnable(SYSCTL_PERIPH_USB0);
00005a  484f              LDR      r0,|L1.408|
00005c  f7fffffe          BL       SysCtlPeripheralEnable
;;;182    
;;;183        //
;;;184        // Set the USB pins to be controlled by the USB controller.
;;;185        //
;;;186        SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
000060  484e              LDR      r0,|L1.412|
000062  f7fffffe          BL       SysCtlPeripheralEnable
;;;187        SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
000066  484d              LDR      r0,|L1.412|
000068  1c80              ADDS     r0,r0,#2
00006a  f7fffffe          BL       SysCtlPeripheralEnable
;;;188        GPIOPinConfigure(GPIO_PD6_USB0EPEN);
00006e  484c              LDR      r0,|L1.416|
000070  f7fffffe          BL       GPIOPinConfigure
;;;189        GPIOPinTypeUSBDigital(GPIO_PORTD_BASE, GPIO_PIN_6);
000074  2140              MOVS     r1,#0x40
000076  484b              LDR      r0,|L1.420|
000078  f7fffffe          BL       GPIOPinTypeUSBDigital
;;;190        SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOL);
00007c  4847              LDR      r0,|L1.412|
00007e  3009              ADDS     r0,r0,#9
000080  f7fffffe          BL       SysCtlPeripheralEnable
;;;191        GPIOPinTypeUSBAnalog(GPIO_PORTL_BASE, GPIO_PIN_6 | GPIO_PIN_7);
000084  21c0              MOVS     r1,#0xc0
000086  4848              LDR      r0,|L1.424|
000088  f7fffffe          BL       GPIOPinTypeUSBAnalog
;;;192        GPIOPinTypeUSBAnalog(GPIO_PORTB_BASE, GPIO_PIN_0 | GPIO_PIN_1);
00008c  2103              MOVS     r1,#3
00008e  4847              LDR      r0,|L1.428|
000090  f7fffffe          BL       GPIOPinTypeUSBAnalog
;;;193    
;;;194        //
;;;195        // Register the host class driver
;;;196        //
;;;197        USBHCDRegisterDrivers(0, g_ppHostClassDrivers, NUM_CLASS_DRIVERS);
000094  2201              MOVS     r2,#1
000096  4946              LDR      r1,|L1.432|
000098  2000              MOVS     r0,#0
00009a  f7fffffe          BL       USBHCDRegisterDrivers
;;;198    
;;;199        //
;;;200        // Open an instance of the mass storage class driver.
;;;201        //
;;;202        g_psMSCInstance = USBHMSCDriveOpen(0, MSCCallback);
00009e  4945              LDR      r1,|L1.436|
0000a0  2000              MOVS     r0,#0
0000a2  f7fffffe          BL       USBHMSCDriveOpen
0000a6  4944              LDR      r1,|L1.440|
0000a8  6008              STR      r0,[r1,#0]  ; g_psMSCInstance
;;;203    
;;;204        //
;;;205        // Initialize the power configuration. This sets the power enable signal
;;;206        // to be active high and does not enable the power fault.
;;;207        //
;;;208        USBHCDPowerConfigInit(0, USBHCD_VBUS_AUTO_HIGH | USBHCD_VBUS_FILTER);
0000aa  4944              LDR      r1,|L1.444|
0000ac  2000              MOVS     r0,#0
0000ae  f7fffffe          BL       USBHCDPowerConfigInit
;;;209    
;;;210        //
;;;211        // Force the USB mode to host with no callback on mode changes since
;;;212        // there should not be any.
;;;213        //
;;;214        USBStackModeSet(0, eUSBModeForceHost, 0);
0000b2  2200              MOVS     r2,#0
0000b4  2104              MOVS     r1,#4
0000b6  4610              MOV      r0,r2
0000b8  f7fffffe          BL       USBStackModeSet
;;;215    
;;;216        //
;;;217        // Wait 10ms for the pin to go low.
;;;218        //
;;;219        SysCtlDelay(gSysClock/100);
0000bc  4840              LDR      r0,|L1.448|
0000be  6800              LDR      r0,[r0,#0]  ; gSysClock
0000c0  2164              MOVS     r1,#0x64
0000c2  fbb0f4f1          UDIV     r4,r0,r1
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       SysCtlDelay
;;;220    
;;;221        //
;;;222        // Initialize the host controller.
;;;223        //
;;;224        USBHCDInit(0, g_pHCDPool, HCD_MEMORY_SIZE);
0000cc  2280              MOVS     r2,#0x80
0000ce  493d              LDR      r1,|L1.452|
0000d0  2000              MOVS     r0,#0
0000d2  f7fffffe          BL       USBHCDInit
;;;225    }
0000d6  bd10              POP      {r4,pc}
;;;226    
                          ENDP

                  SimpleFsReadMediaSector PROC
;;;246    uint32_t
;;;247    SimpleFsReadMediaSector(uint32_t ui32Sector, uint8_t *pui8Buf)
0000d8  b570              PUSH     {r4-r6,lr}
;;;248    {
0000da  4604              MOV      r4,r0
0000dc  460d              MOV      r5,r1
;;;249        //
;;;250        // Return the requested sector from the connected USB mass storage
;;;251        // device.
;;;252        //
;;;253        return(USBHMSCBlockRead(g_psMSCInstance, ui32Sector, pui8Buf, 1));
0000de  2301              MOVS     r3,#1
0000e0  462a              MOV      r2,r5
0000e2  4621              MOV      r1,r4
0000e4  4834              LDR      r0,|L1.440|
0000e6  6800              LDR      r0,[r0,#0]  ; g_psMSCInstance
0000e8  f7fffffe          BL       USBHMSCBlockRead
;;;254    }
0000ec  bd70              POP      {r4-r6,pc}
;;;255    
                          ENDP

                  usb_msg_handler PROC
;;;256    static void usb_msg_handler(usb_msg_t *msg)
0000ee  b510              PUSH     {r4,lr}
;;;257    {
0000f0  4604              MOV      r4,r0
;;;258    	
;;;259    	switch(msg->msg){
0000f2  7820              LDRB     r0,[r4,#0]
0000f4  b150              CBZ      r0,|L1.268|
0000f6  2801              CMP      r0,#1
0000f8  d002              BEQ      |L1.256|
0000fa  2802              CMP      r0,#2
0000fc  d117              BNE      |L1.302|
0000fe  e00e              B        |L1.286|
                  |L1.256|
;;;260    		case USB_STICK_READY:
;;;261    			
;;;262    		   SYS_TRACE(USB_STICK_DEBUG, ("USB_STICK_READY\r\n"));
000100  bf00              NOP      
000102  a031              ADR      r0,|L1.456|
000104  f7fffffe          BL       s_printf
000108  bf00              NOP      
;;;263    			break;
00010a  e011              B        |L1.304|
                  |L1.268|
;;;264    		
;;;265    		case USB_HOST_READY:
;;;266    			SYS_TRACE(USB_STICK_DEBUG, ("USB_HOST_READY\r\n"));
00010c  bf00              NOP      
00010e  a033              ADR      r0,|L1.476|
000110  f7fffffe          BL       s_printf
000114  bf00              NOP      
;;;267    			is_usb_host_ready = true;
000116  2001              MOVS     r0,#1
000118  4935              LDR      r1,|L1.496|
00011a  7008              STRB     r0,[r1,#0]
;;;268    			break;
00011c  e008              B        |L1.304|
                  |L1.286|
;;;269    		
;;;270    		case USB_INTERFACE_CONFIG:
;;;271    			SYS_TRACE(USB_STICK_DEBUG, ("USB_INTERFACE_CONFIG\r\n"));
00011e  bf00              NOP      
000120  a034              ADR      r0,|L1.500|
000122  f7fffffe          BL       s_printf
000126  bf00              NOP      
;;;272    			ConfigureUSBInterface();
000128  f7fffffe          BL       ConfigureUSBInterface
;;;273    			break;
00012c  e000              B        |L1.304|
                  |L1.302|
;;;274    		
;;;275    		default:
;;;276    			break;
00012e  bf00              NOP      
                  |L1.304|
000130  bf00              NOP                            ;263
;;;277    	}
;;;278    	
;;;279    }
000132  bd10              POP      {r4,pc}
;;;280    
                          ENDP

                  usb_stick_task PROC
;;;285    
;;;286    void usb_stick_task(void *para)
000134  b508              PUSH     {r3,lr}
;;;287    {
;;;288    	
;;;289    	usb_msg_t msg;
;;;290    	
;;;291    	gUsbQueue = xQueueCreate(20, sizeof(usb_msg_t));
000136  2200              MOVS     r2,#0
000138  2101              MOVS     r1,#1
00013a  2014              MOVS     r0,#0x14
00013c  f7fffffe          BL       xQueueGenericCreate
000140  4911              LDR      r1,|L1.392|
000142  6008              STR      r0,[r1,#0]  ; gUsbQueue
;;;292    	
;;;293    	OSAL_ASSERT(gUsbQueue != NULL);
000144  4608              MOV      r0,r1
000146  6800              LDR      r0,[r0,#0]  ; gUsbQueue
000148  b940              CBNZ     r0,|L1.348|
00014a  bf00              NOP      
00014c  4a2f              LDR      r2,|L1.524|
00014e  a130              ADR      r1,|L1.528|
000150  a034              ADR      r0,|L1.548|
000152  f7fffffe          BL       s_printf
000156  bf00              NOP      
000158  bf00              NOP      
                  |L1.346|
00015a  e7fe              B        |L1.346|
                  |L1.348|
;;;294    	
;;;295    	while(1){
00015c  e013              B        |L1.390|
                  |L1.350|
;;;296    		
;;;297    		if(is_usb_host_ready == true){
00015e  4824              LDR      r0,|L1.496|
000160  7800              LDRB     r0,[r0,#0]  ; is_usb_host_ready
000162  2801              CMP      r0,#1
000164  d101              BNE      |L1.362|
;;;298    			USBHCDMain();
000166  f7fffffe          BL       USBHCDMain
                  |L1.362|
;;;299    		}
;;;300    
;;;301        if(xQueueReceive(gUsbQueue, &msg, 0)){
00016a  2300              MOVS     r3,#0
00016c  461a              MOV      r2,r3
00016e  4669              MOV      r1,sp
000170  4805              LDR      r0,|L1.392|
000172  6800              LDR      r0,[r0,#0]  ; gUsbQueue
000174  f7fffffe          BL       xQueueGenericReceive
000178  b110              CBZ      r0,|L1.384|
;;;302    			usb_msg_handler(&msg);
00017a  4668              MOV      r0,sp
00017c  f7fffffe          BL       usb_msg_handler
                  |L1.384|
;;;303    		 }
;;;304    		 
;;;305    		vTaskDelay(50/portTICK_RATE_MS);
000180  2032              MOVS     r0,#0x32
000182  f7fffffe          BL       vTaskDelay
                  |L1.390|
000186  e7ea              B        |L1.350|
;;;306      }
;;;307    }
;;;308    
                          ENDP

                  |L1.392|
                          DCD      gUsbQueue
                  |L1.396|
                          DCD      g_eState
                  |L1.400|
                          DCD      0xf0000c00
                  |L1.404|
                          DCD      g_sDMAControlTable
                  |L1.408|
                          DCD      0xf0002800
                  |L1.412|
                          DCD      0xf0000801
                  |L1.416|
                          DCD      0x00031805
                  |L1.420|
                          DCD      0x40007000
                  |L1.424|
                          DCD      0x40062000
                  |L1.428|
                          DCD      0x40005000
                  |L1.432|
                          DCD      g_ppHostClassDrivers
                  |L1.436|
                          DCD      MSCCallback
                  |L1.440|
                          DCD      g_psMSCInstance
                  |L1.444|
                          DCD      0x00010003
                  |L1.448|
                          DCD      gSysClock
                  |L1.452|
                          DCD      g_pHCDPool
                  |L1.456|
0001c8  5553425f          DCB      "USB_STICK_READY\r\n",0
0001cc  53544943
0001d0  4b5f5245
0001d4  4144590d
0001d8  0a00    
0001da  00                DCB      0
0001db  00                DCB      0
                  |L1.476|
0001dc  5553425f          DCB      "USB_HOST_READY\r\n",0
0001e0  484f5354
0001e4  5f524541
0001e8  44590d0a
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L1.496|
                          DCD      is_usb_host_ready
                  |L1.500|
0001f4  5553425f          DCB      "USB_INTERFACE_CONFIG\r\n",0
0001f8  494e5445
0001fc  52464143
000200  455f434f
000204  4e464947
000208  0d0a00  
00020b  00                DCB      0
                  |L1.524|
                          DCD      __FUNCTION__
                  |L1.528|
000210  67557362          DCB      "gUsbQueue != NULL",0
000214  51756575
000218  6520213d
00021c  204e554c
000220  4c00    
000222  00                DCB      0
000223  00                DCB      0
                  |L1.548|
000224  28257329          DCB      "(%s) has assert failed at %s.\n",0
000228  20686173
00022c  20617373
000230  65727420
000234  6661696c
000238  65642061
00023c  74202573
000240  2e0a00  
000243  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=10

                  g_sDMAControlTable
                          %        96
                  g_pHCDPool
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_ppHostClassDrivers
                          DCD      g_sUSBHostMSCClassDriver
                  __FUNCTION__
000004  7573625f          DCB      0x75,0x73,0x62,0x5f
000008  73746963          DCB      0x73,0x74,0x69,0x63
00000c  6b5f7461          DCB      0x6b,0x5f,0x74,0x61
000010  736b00            DCB      0x73,0x6b,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  is_usb_host_ready
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  g_psMSCInstance
                          DCD      0x00000000
                  g_eState
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  gUsbQueue
                          DCD      0x00000000
