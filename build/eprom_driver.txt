; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\build\eprom_driver.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\eprom_driver.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\driver -I.\usblib -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C1290NCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DTM4C1290NCZAD --omf_browse=.\build\eprom_driver.crf driver\EPRom_driver.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  epprom_sda PROC
;;;8      
;;;9      void epprom_sda(int level)
000000  b510              PUSH     {r4,lr}
;;;10     {
000002  4604              MOV      r4,r0
;;;11     	 if(level){
000004  b154              CBZ      r4,|L1.28|
;;;12     		GPIOPinTypeGPIOInput(EPROM_SDA_PORT, EPROM_SDA_PIN);
000006  2108              MOVS     r1,#8
000008  4856              LDR      r0,|L1.356|
00000a  f7fffffe          BL       GPIOPinTypeGPIOInput
;;;13     		GPIO_PIN_SET(EPROM_SDA_PORT, EPROM_SDA_PIN, 1);
00000e  bf00              NOP      
000010  2208              MOVS     r2,#8
000012  4611              MOV      r1,r2
000014  4853              LDR      r0,|L1.356|
000016  f7fffffe          BL       GPIOPinWrite
00001a  e00a              B        |L1.50|
                  |L1.28|
;;;14     	}else{
;;;15     		GPIOPinTypeGPIOOutput(EPROM_SDA_PORT, EPROM_SDA_PIN);
00001c  2108              MOVS     r1,#8
00001e  4851              LDR      r0,|L1.356|
000020  f7fffffe          BL       GPIOPinTypeGPIOOutput
;;;16     		GPIO_PIN_SET(EPROM_SDA_PORT, EPROM_SDA_PIN, 0);
000024  bf00              NOP      
000026  2200              MOVS     r2,#0
000028  2108              MOVS     r1,#8
00002a  484e              LDR      r0,|L1.356|
00002c  f7fffffe          BL       GPIOPinWrite
000030  bf00              NOP      
                  |L1.50|
;;;17     	}
;;;18     }
000032  bd10              POP      {r4,pc}
;;;19     
                          ENDP

                  epprom_scl PROC
;;;20     
;;;21     void epprom_scl(int level)
000034  b510              PUSH     {r4,lr}
;;;22     {
000036  4604              MOV      r4,r0
;;;23     	if(level){
000038  b154              CBZ      r4,|L1.80|
;;;24     		GPIOPinTypeGPIOInput(EPROM_SCL_PORT, EPROM_SCL_PIN);
00003a  2104              MOVS     r1,#4
00003c  4849              LDR      r0,|L1.356|
00003e  f7fffffe          BL       GPIOPinTypeGPIOInput
;;;25     		GPIO_PIN_SET(EPROM_SCL_PORT, EPROM_SCL_PIN, 1);
000042  bf00              NOP      
000044  2204              MOVS     r2,#4
000046  4611              MOV      r1,r2
000048  4846              LDR      r0,|L1.356|
00004a  f7fffffe          BL       GPIOPinWrite
00004e  e00a              B        |L1.102|
                  |L1.80|
;;;26     	}else{
;;;27     		GPIOPinTypeGPIOOutput(EPROM_SCL_PORT, EPROM_SCL_PIN);
000050  2104              MOVS     r1,#4
000052  4844              LDR      r0,|L1.356|
000054  f7fffffe          BL       GPIOPinTypeGPIOOutput
;;;28     		GPIO_PIN_SET(EPROM_SCL_PORT, EPROM_SCL_PIN, 0);
000058  bf00              NOP      
00005a  2200              MOVS     r2,#0
00005c  2104              MOVS     r1,#4
00005e  4841              LDR      r0,|L1.356|
000060  f7fffffe          BL       GPIOPinWrite
000064  bf00              NOP      
                  |L1.102|
;;;29     	}  
;;;30     }
000066  bd10              POP      {r4,pc}
;;;31     
                          ENDP

                  epprom_sda_in PROC
;;;32     
;;;33     uint8 epprom_sda_in(void)
000068  b510              PUSH     {r4,lr}
;;;34     {
;;;35     	 return (GPIO_ReadSinglePin(EPROM_SDA_PORT, EPROM_SDA_PIN));
00006a  2108              MOVS     r1,#8
00006c  483d              LDR      r0,|L1.356|
00006e  f7fffffe          BL       GPIO_ReadSinglePin
;;;36     }
000072  bd10              POP      {r4,pc}
;;;37     
                          ENDP

                  eeprom_write PROC
;;;38     int eeprom_write(uint32 addr, uint8 *buf, size_t size)
000074  e92d41f0          PUSH     {r4-r8,lr}
;;;39     {
000078  4607              MOV      r7,r0
00007a  460d              MOV      r5,r1
00007c  4614              MOV      r4,r2
;;;40     	uint8 write_size;
;;;41     	size_t index = 0;
00007e  f04f0800          MOV      r8,#0
;;;42     	
;;;43     	OSAL_ASSERT(buf != NULL);
000082  b945              CBNZ     r5,|L1.150|
000084  bf00              NOP      
000086  4a38              LDR      r2,|L1.360|
000088  a138              ADR      r1,|L1.364|
00008a  a03b              ADR      r0,|L1.376|
00008c  f7fffffe          BL       s_printf
000090  bf00              NOP      
000092  bf00              NOP      
                  |L1.148|
000094  e7fe              B        |L1.148|
                  |L1.150|
;;;44     	
;;;45     	do{
000096  bf00              NOP      
                  |L1.152|
;;;46     		if(size > EPROM_PAGE_SIZE){
000098  2c10              CMP      r4,#0x10
00009a  d901              BLS      |L1.160|
;;;47     			write_size = EPROM_PAGE_SIZE;
00009c  2610              MOVS     r6,#0x10
00009e  e000              B        |L1.162|
                  |L1.160|
;;;48     		}else{
;;;49     			write_size = size;
0000a0  b2e6              UXTB     r6,r4
                  |L1.162|
;;;50     		}
;;;51     		if(osal_iic_write_buf(EPROM, addr, buf, write_size) < 0){
0000a2  4633              MOV      r3,r6
0000a4  462a              MOV      r2,r5
0000a6  4639              MOV      r1,r7
0000a8  2000              MOVS     r0,#0
0000aa  f7fffffe          BL       osal_iic_write_buf
0000ae  2800              CMP      r0,#0
0000b0  da03              BGE      |L1.186|
;;;52     			return -1;
0000b2  f04f30ff          MOV      r0,#0xffffffff
                  |L1.182|
;;;53     		}
;;;54     		buf += write_size;
;;;55     		index += write_size;
;;;56     		addr += write_size;
;;;57     		bsp_delay_ms(50);
;;;58     		
;;;59     	}while(index < size);
;;;60     	
;;;61     	
;;;62     	return size;
;;;63     }
0000b6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.186|
0000ba  4435              ADD      r5,r5,r6              ;54
0000bc  44b0              ADD      r8,r8,r6              ;55
0000be  4437              ADD      r7,r7,r6              ;56
0000c0  2032              MOVS     r0,#0x32              ;57
0000c2  f7fffffe          BL       bsp_delay_ms
0000c6  45a0              CMP      r8,r4                 ;59
0000c8  d3e6              BCC      |L1.152|
0000ca  4620              MOV      r0,r4                 ;62
0000cc  e7f3              B        |L1.182|
;;;64     
                          ENDP

                  eeprom_read PROC
;;;65     int eeprom_read(uint32 addr, uint8 *buf, size_t size)
0000ce  b570              PUSH     {r4-r6,lr}
;;;66     {
0000d0  4606              MOV      r6,r0
0000d2  460c              MOV      r4,r1
0000d4  4615              MOV      r5,r2
;;;67     	OSAL_ASSERT(buf != NULL);
0000d6  b944              CBNZ     r4,|L1.234|
0000d8  bf00              NOP      
0000da  4a2f              LDR      r2,|L1.408|
0000dc  a123              ADR      r1,|L1.364|
0000de  a026              ADR      r0,|L1.376|
0000e0  f7fffffe          BL       s_printf
0000e4  bf00              NOP      
0000e6  bf00              NOP      
                  |L1.232|
0000e8  e7fe              B        |L1.232|
                  |L1.234|
;;;68     	
;;;69     	if(osal_iic_read_buf(EPROM, addr, buf, size) < 0){
0000ea  462b              MOV      r3,r5
0000ec  4622              MOV      r2,r4
0000ee  4631              MOV      r1,r6
0000f0  2000              MOVS     r0,#0
0000f2  f7fffffe          BL       osal_iic_read_buf
0000f6  2800              CMP      r0,#0
0000f8  da02              BGE      |L1.256|
;;;70     		return -1;
0000fa  f04f30ff          MOV      r0,#0xffffffff
                  |L1.254|
;;;71     	}
;;;72     	
;;;73     	return size;
;;;74     }
0000fe  bd70              POP      {r4-r6,pc}
                  |L1.256|
000100  4628              MOV      r0,r5                 ;73
000102  e7fc              B        |L1.254|
;;;75     
                          ENDP

                  eep_write PROC
;;;76     /*******************************For Test*********************************************/
;;;77     int eep_write(struct cmd_tbl_s *cmdtp, int argc, char * const argv[])
000104  e92d47f0          PUSH     {r4-r10,lr}
;;;78     {
000108  4680              MOV      r8,r0
00010a  4689              MOV      r9,r1
00010c  4614              MOV      r4,r2
;;;79       int retval;
;;;80     	
;;;81     	retval = eeprom_write(atoi(argv[1]), (uint8 *)argv[2], strlen(argv[2]));
00010e  68a0              LDR      r0,[r4,#8]
000110  f7fffffe          BL       strlen
000114  4606              MOV      r6,r0
000116  6860              LDR      r0,[r4,#4]
000118  f7fffffe          BL       atoi
00011c  4607              MOV      r7,r0
00011e  4632              MOV      r2,r6
000120  68a1              LDR      r1,[r4,#8]
000122  f7fffffe          BL       eeprom_write
000126  4605              MOV      r5,r0
;;;82     	
;;;83     	if(retval < 0){
;;;84     		//SYS_TRACE("eeprom write fail\r\n");
;;;85     	}else{
;;;86     		//SYS_TRACE("eeprom write %d bytes success\r\n", retval);
;;;87     	}
;;;88     	
;;;89     	return 0;
000128  2000              MOVS     r0,#0
;;;90     }
00012a  e8bd87f0          POP      {r4-r10,pc}
;;;91     
                          ENDP

                  eep_read PROC
;;;94     
;;;95     int eep_read(struct cmd_tbl_s *cmdtp, int argc, char * const argv[])
00012e  e92d43f0          PUSH     {r4-r9,lr}
;;;96     {
000132  b091              SUB      sp,sp,#0x44
000134  4680              MOV      r8,r0
000136  4689              MOV      r9,r1
000138  4614              MOV      r4,r2
;;;97       int retval;
;;;98     	uint8 buf[64] = {0};
00013a  2140              MOVS     r1,#0x40
00013c  a801              ADD      r0,sp,#4
00013e  f7fffffe          BL       __aeabi_memclr4
;;;99     	
;;;100    	retval = eeprom_read(atoi(argv[1]), buf, atoi(argv[2]));
000142  68a0              LDR      r0,[r4,#8]
000144  f7fffffe          BL       atoi
000148  4606              MOV      r6,r0
00014a  6860              LDR      r0,[r4,#4]
00014c  f7fffffe          BL       atoi
000150  4607              MOV      r7,r0
000152  4632              MOV      r2,r6
000154  a901              ADD      r1,sp,#4
000156  f7fffffe          BL       eeprom_read
00015a  4605              MOV      r5,r0
;;;101    	
;;;102    	if(retval < 0){
;;;103    		//SYS_TRACE("eeprom read fail\r\n");
;;;104    	}else{
;;;105    		//SYS_TRACE("eeprom read=[%s]\r\n", buf);
;;;106    	}
;;;107    	
;;;108    	return 0;
00015c  2000              MOVS     r0,#0
;;;109    }
00015e  b011              ADD      sp,sp,#0x44
000160  e8bd83f0          POP      {r4-r9,pc}
;;;110    
                          ENDP

                  |L1.356|
                          DCD      0x40005000
                  |L1.360|
                          DCD      __FUNCTION__
                  |L1.364|
00016c  62756620          DCB      "buf != NULL",0
000170  213d204e
000174  554c4c00
                  |L1.376|
000178  28257329          DCB      "(%s) has assert failed at %s.\n",0
00017c  20686173
000180  20617373
000184  65727420
000188  6661696c
00018c  65642061
000190  74202573
000194  2e0a00  
000197  00                DCB      0
                  |L1.408|
                          DCD      |symbol_number.10|

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  65657072          DCB      0x65,0x65,0x70,0x72
000004  6f6d5f77          DCB      0x6f,0x6d,0x5f,0x77
000008  72697465          DCB      0x72,0x69,0x74,0x65
00000c  00                DCB      0x00
                  |symbol_number.10|
00000d  656570            DCB      0x65,0x65,0x70
000010  726f6d5f          DCB      0x72,0x6f,0x6d,0x5f
000014  72656164          DCB      0x72,0x65,0x61,0x64
000018  00                DCB      0x00

                          AREA ||.conststrlit||, DATA, READONLY, ALIGN=0

000000  65707077          DCB      0x65,0x70,0x70,0x77
000004  00656570          DCB      0x00,0x65,0x65,0x70
000008  726f6d20          DCB      0x72,0x6f,0x6d,0x20
00000c  77726974          DCB      0x77,0x72,0x69,0x74
000010  65207465          DCB      0x65,0x20,0x74,0x65
000014  73740065          DCB      0x73,0x74,0x00,0x65
000018  70707200          DCB      0x70,0x70,0x72,0x00
00001c  65657072          DCB      0x65,0x65,0x70,0x72
000020  6f6d2072          DCB      0x6f,0x6d,0x20,0x72
000024  65616420          DCB      0x65,0x61,0x64,0x20
000028  74657374          DCB      0x74,0x65,0x73,0x74
00002c  00                DCB      0x00

                          AREA INIT_CMD, DATA, READONLY, ALIGN=2

                  __init_cmd_eppw
                  ||__tagsym$$used||
                          DCD      ||.conststrlit||
                          DCD      0x00000003
                          DCD      eep_write
                          DCD      ||.conststrlit||+0x5
                  __init_cmd_eppr
                  |symbol_number.22|
                          DCD      ||.conststrlit||+0x17
                          DCD      0x00000003
                          DCD      eep_read
                          DCD      ||.conststrlit||+0x1c
