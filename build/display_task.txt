; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\build\display_task.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\display_task.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\driver -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C1290NCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DTM4C1290NCZAD --omf_browse=.\build\display_task.crf Task\Display_Task.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  dis_print PROC
;;;28     
;;;29     static void dis_print(uint8 line, char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;30     {
000002  b530              PUSH     {r4,r5,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
;;;31     	 uint8 j;
;;;32     	 char buf[LCD_LINE_LEN + 1] = {0};
000008  2114              MOVS     r1,#0x14
00000a  a802              ADD      r0,sp,#8
00000c  f7fffffe          BL       __aeabi_memclr4
;;;33        va_list ap;
;;;34     
;;;35        va_start(ap, fmt);
000010  a80c              ADD      r0,sp,#0x30
000012  9001              STR      r0,[sp,#4]
;;;36        vsprintf(buf, fmt, ap);
000014  a802              ADD      r0,sp,#8
000016  9a01              LDR      r2,[sp,#4]
000018  990b              LDR      r1,[sp,#0x2c]
00001a  f7fffffe          BL       __c89vsprintf
;;;37        va_end(ap);
00001e  2000              MOVS     r0,#0
000020  9001              STR      r0,[sp,#4]
;;;38     
;;;39        lcd_write_cmd(line);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       lcd_write_cmd
;;;40        bsp_delay_us(47);
000028  202f              MOVS     r0,#0x2f
00002a  f7fffffe          BL       bsp_delay_us
;;;41        for(j = 0; j < LCD_LINE_LEN; j++){
00002e  2400              MOVS     r4,#0
000030  e02f              B        |L1.146|
                  |L1.50|
;;;42     		 if(buf[j] == '<'){
000032  a802              ADD      r0,sp,#8
000034  5d00              LDRB     r0,[r0,r4]
000036  283c              CMP      r0,#0x3c
000038  d103              BNE      |L1.66|
;;;43     			 lcd_write_data(0);
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       lcd_write_data
000040  e022              B        |L1.136|
                  |L1.66|
;;;44     		 }else if(buf[j] == '>'){
000042  a802              ADD      r0,sp,#8
000044  5d00              LDRB     r0,[r0,r4]
000046  283e              CMP      r0,#0x3e
000048  d103              BNE      |L1.82|
;;;45     			 lcd_write_data(6);
00004a  2006              MOVS     r0,#6
00004c  f7fffffe          BL       lcd_write_data
000050  e01a              B        |L1.136|
                  |L1.82|
;;;46     		 }else if(buf[j] == '@'){
000052  a802              ADD      r0,sp,#8
000054  5d00              LDRB     r0,[r0,r4]
000056  2840              CMP      r0,#0x40
000058  d103              BNE      |L1.98|
;;;47     			 lcd_write_data(4);
00005a  2004              MOVS     r0,#4
00005c  f7fffffe          BL       lcd_write_data
000060  e012              B        |L1.136|
                  |L1.98|
;;;48     		 }else if(buf[j] == 0){
000062  a802              ADD      r0,sp,#8
000064  5d00              LDRB     r0,[r0,r4]
000066  b918              CBNZ     r0,|L1.112|
;;;49     			 lcd_write_data(' ');
000068  2020              MOVS     r0,#0x20
00006a  f7fffffe          BL       lcd_write_data
00006e  e00b              B        |L1.136|
                  |L1.112|
;;;50     		 }else if(buf[j] == '^'){
000070  a802              ADD      r0,sp,#8
000072  5d00              LDRB     r0,[r0,r4]
000074  285e              CMP      r0,#0x5e
000076  d103              BNE      |L1.128|
;;;51     			 lcd_write_data(7);
000078  2007              MOVS     r0,#7
00007a  f7fffffe          BL       lcd_write_data
00007e  e003              B        |L1.136|
                  |L1.128|
;;;52     		 }else{
;;;53     			 lcd_write_data(buf[j]);
000080  a902              ADD      r1,sp,#8
000082  5d08              LDRB     r0,[r1,r4]
000084  f7fffffe          BL       lcd_write_data
                  |L1.136|
;;;54     		 }
;;;55     		 
;;;56     		 bsp_delay_us(47);
000088  202f              MOVS     r0,#0x2f
00008a  f7fffffe          BL       bsp_delay_us
00008e  1c60              ADDS     r0,r4,#1              ;41
000090  b2c4              UXTB     r4,r0                 ;41
                  |L1.146|
000092  2c10              CMP      r4,#0x10              ;41
000094  dbcd              BLT      |L1.50|
;;;57     	 }
;;;58        
;;;59     }
000096  b007              ADD      sp,sp,#0x1c
000098  bc30              POP      {r4,r5}
00009a  f85dfb14          LDR      pc,[sp],#0x14
;;;60     
                          ENDP

                  display_task_msg_fetch PROC
;;;61     uint32_t display_task_msg_fetch(xQueueHandle xQueue, void * const pvBuffer, portTickType timeout)
00009e  e92d41f0          PUSH     {r4-r8,lr}
;;;62     {
0000a2  4606              MOV      r6,r0
0000a4  460f              MOV      r7,r1
0000a6  4614              MOV      r4,r2
;;;63     	portTickType starttime;
;;;64     	
;;;65     	/* Get the starting time. */
;;;66       starttime = xTaskGetTickCount();
0000a8  f7fffffe          BL       xTaskGetTickCount
0000ac  4605              MOV      r5,r0
;;;67     	
;;;68     	/* See if there is a timeout. */
;;;69       if(timeout != 0) {
0000ae  b17c              CBZ      r4,|L1.208|
;;;70         /* Receive a message from the queue. */
;;;71         if(xQueueReceive(xQueue, pvBuffer, timeout / portTICK_RATE_MS) == pdPASS) {
0000b0  2300              MOVS     r3,#0
0000b2  4622              MOV      r2,r4
0000b4  4639              MOV      r1,r7
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       xQueueGenericReceive
0000bc  2801              CMP      r0,#1
0000be  d104              BNE      |L1.202|
;;;72           /* Return the amount of time it took for the message to be received. */
;;;73           return (xTaskGetTickCount() - starttime) * portTICK_RATE_MS;
0000c0  f7fffffe          BL       xTaskGetTickCount
0000c4  1b40              SUBS     r0,r0,r5
                  |L1.198|
;;;74         } else {
;;;75           /* No message arrived in the allotted time. */
;;;76           return SYS_ARCH_TIMEOUT;
;;;77         }
;;;78       } else {
;;;79         /* Try to receive a message until one arrives. */
;;;80         while(xQueueReceive(xQueue, pvBuffer, portMAX_DELAY) != pdPASS);
;;;81     
;;;82         /* Return the amount of time it took for the message to be received. */
;;;83         return (xTaskGetTickCount() - starttime) * portTICK_RATE_MS;
;;;84       }
;;;85     	
;;;86     }
0000c6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.202|
0000ca  f04f30ff          MOV      r0,#0xffffffff        ;76
0000ce  e7fa              B        |L1.198|
                  |L1.208|
0000d0  bf00              NOP                            ;80
                  |L1.210|
0000d2  2300              MOVS     r3,#0                 ;80
0000d4  1e5a              SUBS     r2,r3,#1              ;80
0000d6  4639              MOV      r1,r7                 ;80
0000d8  4630              MOV      r0,r6                 ;80
0000da  f7fffffe          BL       xQueueGenericReceive
0000de  2801              CMP      r0,#1                 ;80
0000e0  d1f7              BNE      |L1.210|
0000e2  f7fffffe          BL       xTaskGetTickCount
0000e6  1b40              SUBS     r0,r0,r5              ;83
0000e8  e7ed              B        |L1.198|
;;;87     
                          ENDP

                  display_msg_handler PROC
;;;88     
;;;89     void display_msg_handler(dis_msg_t *msg)
0000ea  bf00              NOP      
;;;90     {
;;;91     	switch(msg->id){
;;;92     		
;;;93     		default:
;;;94     			break;
0000ec  bf00              NOP      
0000ee  bf00              NOP      
;;;95     	}
;;;96     	
;;;97     }
0000f0  4770              BX       lr
;;;98     
                          ENDP

                  display_task PROC
;;;99     void display_task(void *parameter)
0000f2  b508              PUSH     {r3,lr}
;;;100    {
;;;101    	 dis_msg_t msg;
;;;102       uint32_t time_needed;
;;;103    	 struct sys_timeo *tmptimeout;
;;;104    	 sys_timeout_handler handler;
;;;105    	 void *arg;
;;;106    	
;;;107    	 SYS_TRACE(DIS_TASK_DEBUG, ("display_task:display task running\r\n"));
0000f4  bf00              NOP      
0000f6  a03e              ADR      r0,|L1.496|
0000f8  f7fffffe          BL       s_printf
0000fc  bf00              NOP      
;;;108    	
;;;109    	 osal_timeout_init();
0000fe  f7fffffe          BL       osal_timeout_init
;;;110    	
;;;111    	 gDisQueue = xQueueCreate(20, sizeof(dis_msg_t));
000102  2200              MOVS     r2,#0
000104  2102              MOVS     r1,#2
000106  2014              MOVS     r0,#0x14
000108  f7fffffe          BL       xQueueGenericCreate
00010c  4941              LDR      r1,|L1.532|
00010e  6008              STR      r0,[r1,#0]  ; gDisQueue
;;;112    	 OSAL_ASSERT(gDisQueue != NULL);
000110  4608              MOV      r0,r1
000112  6800              LDR      r0,[r0,#0]  ; gDisQueue
000114  b940              CBNZ     r0,|L1.296|
000116  bf00              NOP      
000118  4a3f              LDR      r2,|L1.536|
00011a  a140              ADR      r1,|L1.540|
00011c  a044              ADR      r0,|L1.560|
00011e  f7fffffe          BL       s_printf
000122  bf00              NOP      
000124  bf00              NOP      
                  |L1.294|
000126  e7fe              B        |L1.294|
                  |L1.296|
;;;113    
;;;114    	while(1){
000128  e042              B        |L1.432|
                  |L1.298|
;;;115    	
;;;116    	again:
00012a  bf00              NOP      
                  |L1.300|
;;;117    		if(!gnext_timeout){
00012c  4848              LDR      r0,|L1.592|
00012e  6800              LDR      r0,[r0,#0]  ; gnext_timeout
000130  b950              CBNZ     r0,|L1.328|
;;;118    			time_needed = display_task_msg_fetch(gDisQueue, &msg, 0);
000132  2200              MOVS     r2,#0
000134  4669              MOV      r1,sp
000136  4837              LDR      r0,|L1.532|
000138  6800              LDR      r0,[r0,#0]  ; gDisQueue
00013a  f7fffffe          BL       display_task_msg_fetch
00013e  4605              MOV      r5,r0
;;;119    			
;;;120    			display_msg_handler(&msg);
000140  4668              MOV      r0,sp
000142  f7fffffe          BL       display_msg_handler
000146  e033              B        |L1.432|
                  |L1.328|
;;;121    		}else{
;;;122    			if(gnext_timeout->time > 0){
000148  4841              LDR      r0,|L1.592|
00014a  6800              LDR      r0,[r0,#0]  ; gnext_timeout
00014c  6840              LDR      r0,[r0,#4]
00014e  b148              CBZ      r0,|L1.356|
;;;123            time_needed = display_task_msg_fetch(gDisQueue, &msg, gnext_timeout->time);
000150  483f              LDR      r0,|L1.592|
000152  6800              LDR      r0,[r0,#0]  ; gnext_timeout
000154  4669              MOV      r1,sp
000156  6842              LDR      r2,[r0,#4]
000158  482e              LDR      r0,|L1.532|
00015a  6800              LDR      r0,[r0,#0]  ; gDisQueue
00015c  f7fffffe          BL       display_task_msg_fetch
000160  4605              MOV      r5,r0
000162  e001              B        |L1.360|
                  |L1.356|
;;;124    			}else{
;;;125    				time_needed = SYS_ARCH_TIMEOUT;
000164  f04f35ff          MOV      r5,#0xffffffff
                  |L1.360|
;;;126    			}
;;;127    			
;;;128    			/* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
;;;129             could be fetched. We should now call the timeout handler and
;;;130             deallocate the memory allocated for the timeout. */
;;;131    			if(time_needed == SYS_ARCH_TIMEOUT){
000168  1c68              ADDS     r0,r5,#1
00016a  d10d              BNE      |L1.392|
;;;132    				tmptimeout = gnext_timeout;
00016c  4838              LDR      r0,|L1.592|
00016e  6804              LDR      r4,[r0,#0]  ; gnext_timeout
;;;133    				gnext_timeout = tmptimeout->next;
000170  4937              LDR      r1,|L1.592|
000172  6820              LDR      r0,[r4,#0]
000174  6008              STR      r0,[r1,#0]  ; gnext_timeout
;;;134    				handler = tmptimeout->h;
000176  68a6              LDR      r6,[r4,#8]
;;;135    				arg = tmptimeout->arg;
000178  68e7              LDR      r7,[r4,#0xc]
;;;136    				
;;;137    				vPortFree(tmptimeout);
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       vPortFree
;;;138    				
;;;139    				if(handler != NULL){
000180  b10e              CBZ      r6,|L1.390|
;;;140    					handler(arg);
000182  4638              MOV      r0,r7
000184  47b0              BLX      r6
                  |L1.390|
;;;141    				}
;;;142    				
;;;143    				goto again;
000186  e7d1              B        |L1.300|
                  |L1.392|
;;;144    				
;;;145    			}else{
;;;146    				/* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
;;;147             occured. The time variable is set to the number of
;;;148             milliseconds we waited for the message. */
;;;149    				
;;;150    				if (time_needed < gnext_timeout->time) {
000188  4831              LDR      r0,|L1.592|
00018a  6800              LDR      r0,[r0,#0]  ; gnext_timeout
00018c  6840              LDR      r0,[r0,#4]
00018e  42a8              CMP      r0,r5
000190  d907              BLS      |L1.418|
;;;151    					gnext_timeout->time -= time_needed;
000192  482f              LDR      r0,|L1.592|
000194  6800              LDR      r0,[r0,#0]  ; gnext_timeout
000196  6840              LDR      r0,[r0,#4]
000198  1b40              SUBS     r0,r0,r5
00019a  492d              LDR      r1,|L1.592|
00019c  6809              LDR      r1,[r1,#0]  ; gnext_timeout
00019e  6048              STR      r0,[r1,#4]
0001a0  e003              B        |L1.426|
                  |L1.418|
;;;152    				} else {
;;;153    					gnext_timeout->time = 0;
0001a2  2000              MOVS     r0,#0
0001a4  492a              LDR      r1,|L1.592|
0001a6  6809              LDR      r1,[r1,#0]  ; gnext_timeout
0001a8  6048              STR      r0,[r1,#4]
                  |L1.426|
;;;154    				}
;;;155    				
;;;156    				display_msg_handler(&msg);
0001aa  4668              MOV      r0,sp
0001ac  f7fffffe          BL       display_msg_handler
                  |L1.432|
0001b0  e7bb              B        |L1.298|
;;;157    			}
;;;158    			
;;;159    		}
;;;160    		
;;;161    	}
;;;162    	
;;;163    }
;;;164    
                          ENDP

                  dis_send_msg PROC
;;;165    void dis_send_msg(dis_msg_type_t type, menu_id_t id)
0001b2  b538              PUSH     {r3-r5,lr}
;;;166    {
0001b4  4605              MOV      r5,r0
0001b6  460c              MOV      r4,r1
;;;167    	 dis_msg_t msg;
;;;168    
;;;169       msg.msg = type;
0001b8  f88d5000          STRB     r5,[sp,#0]
;;;170       msg.id = id;	
0001bc  f88d4001          STRB     r4,[sp,#1]
;;;171    	 
;;;172    	 xQueueSend(gDisQueue, &msg, portMAX_DELAY);
0001c0  2300              MOVS     r3,#0
0001c2  1e5a              SUBS     r2,r3,#1
0001c4  4669              MOV      r1,sp
0001c6  4813              LDR      r0,|L1.532|
0001c8  6800              LDR      r0,[r0,#0]  ; gDisQueue
0001ca  f7fffffe          BL       xQueueGenericSend
;;;173    }
0001ce  bd38              POP      {r3-r5,pc}
;;;174    
                          ENDP

                  dis_send_msg_isr PROC
;;;175    void dis_send_msg_isr(dis_msg_type_t type, menu_id_t id)
0001d0  b538              PUSH     {r3-r5,lr}
;;;176    {
0001d2  4605              MOV      r5,r0
0001d4  460c              MOV      r4,r1
;;;177    	 dis_msg_t msg;
;;;178    
;;;179       msg.msg = type;
0001d6  f88d5000          STRB     r5,[sp,#0]
;;;180    	 msg.id = id;
0001da  f88d4001          STRB     r4,[sp,#1]
;;;181    	
;;;182    	 xQueueSendToFrontFromISR(gDisQueue, &msg, NULL);
0001de  2301              MOVS     r3,#1
0001e0  2200              MOVS     r2,#0
0001e2  4669              MOV      r1,sp
0001e4  480b              LDR      r0,|L1.532|
0001e6  6800              LDR      r0,[r0,#0]  ; gDisQueue
0001e8  f7fffffe          BL       xQueueGenericSendFromISR
;;;183    }
0001ec  bd38              POP      {r3-r5,pc}
;;;184    
                          ENDP

0001ee  0000              DCW      0x0000
                  |L1.496|
0001f0  64697370          DCB      "display_task:display task running\r\n",0
0001f4  6c61795f
0001f8  7461736b
0001fc  3a646973
000200  706c6179
000204  20746173
000208  6b207275
00020c  6e6e696e
000210  670d0a00
                  |L1.532|
                          DCD      gDisQueue
                  |L1.536|
                          DCD      __FUNCTION__
                  |L1.540|
00021c  67446973          DCB      "gDisQueue != NULL",0
000220  51756575
000224  6520213d
000228  204e554c
00022c  4c00    
00022e  00                DCB      0
00022f  00                DCB      0
                  |L1.560|
000230  28257329          DCB      "(%s) has assert failed at %s.\n",0
000234  20686173
000238  20617373
00023c  65727420
000240  6661696c
000244  65642061
000248  74202573
00024c  2e0a00  
00024f  00                DCB      0
                  |L1.592|
                          DCD      gnext_timeout

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  64697370          DCB      0x64,0x69,0x73,0x70
000004  6c61795f          DCB      0x6c,0x61,0x79,0x5f
000008  7461736b          DCB      0x74,0x61,0x73,0x6b
00000c  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=2

                  gDisQueue
                          DCD      0x00000000
                  gMenuHead
                          DCD      0x00000000
                  cur_menu
                          DCD      0x00000000
                  last_menu
                          DCD      0x00000000
