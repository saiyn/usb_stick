; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\build\simple_fs.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\simple_fs.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I.\FreeRTOS\include -I.\inc -I.\startup -I.\driverlib -I.\Application -I.\FreeRTOS\portable -I.\Task -I.\driver -I.\usblib -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\TI\TM4C129 -Drvmdk -DPART_TM4C1290NCZAD -DRTOS_FREERTOS -DTARGET_IS_SNOWFLAKE_RA0 -DTM4C1290NCZAD --omf_browse=.\build\simple_fs.crf Application\simple_fs.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SimpleFsInit PROC
;;;280    uint32_t
;;;281    SimpleFsInit(uint8_t *pui8SectorBuf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;282    {
000004  4605              MOV      r5,r0
;;;283        tMasterBootRecord *pMBR;
;;;284        tPartitionTable *pPart;
;;;285        tBootSector *pBoot;
;;;286    
;;;287        //
;;;288        // Save the sector buffer pointer.  The input parameter is assumed
;;;289        // to be good.
;;;290        //
;;;291        g_pui8SectorBuf = pui8SectorBuf;
000006  48c3              LDR      r0,|L1.788|
000008  6005              STR      r5,[r0,#0]  ; g_pui8SectorBuf
;;;292    
;;;293        //
;;;294        // Get the MBR
;;;295        //
;;;296        if(SimpleFsReadMediaSector(0, pui8SectorBuf))
00000a  4629              MOV      r1,r5
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       SimpleFsReadMediaSector
000012  b110              CBZ      r0,|L1.26|
;;;297        {
;;;298            return(1);
000014  2001              MOVS     r0,#1
                  |L1.22|
;;;299        }
;;;300    
;;;301        //
;;;302        // Verify MBR signature - bare minimum validation of MBR.
;;;303        //
;;;304        pMBR = (tMasterBootRecord *)pui8SectorBuf;
;;;305        if(pMBR->ui16Sig != 0xAA55)
;;;306        {
;;;307            return(1);
;;;308        }
;;;309    
;;;310        //
;;;311        // See if this is a MBR or a boot sector.
;;;312        //
;;;313        pBoot = (tBootSector *)pui8SectorBuf;
;;;314        if((strncmp(pBoot->ext.sExt16.pcFsType, "FAT", 3) != 0) &&
;;;315           (strncmp(pBoot->ext.sExt32.pcFsType, "FAT32", 5) != 0))
;;;316        {
;;;317            //
;;;318            // Get the first partition table
;;;319            //
;;;320            pPart = &(pMBR->sPartTable[0]);
;;;321    
;;;322            //
;;;323            // Could optionally check partition type here ...
;;;324            //
;;;325    
;;;326            //
;;;327            // Get the partition location and size
;;;328            //
;;;329            sPartInfo.ui32FirstSector = pPart->ui32FirstSector;
;;;330            sPartInfo.ui32NumBlocks = pPart->ui32NumBlocks;
;;;331    
;;;332            //
;;;333            // Read the boot sector from the partition
;;;334            //
;;;335            if(SimpleFsReadMediaSector(sPartInfo.ui32FirstSector, pui8SectorBuf))
;;;336            {
;;;337                return(1);
;;;338            }
;;;339        }
;;;340        else
;;;341        {
;;;342            //
;;;343            // Extract the number of sectors from the boot sector.
;;;344            //
;;;345            sPartInfo.ui32FirstSector = 0;
;;;346            if(pBoot->ui16TotalSectorsSmall == 0)
;;;347            {
;;;348                sPartInfo.ui32NumBlocks = pBoot->ui32TotalSectorsBig;
;;;349            }
;;;350            else
;;;351            {
;;;352                sPartInfo.ui32NumBlocks = pBoot->ui16TotalSectorsSmall;
;;;353            }
;;;354        }
;;;355    
;;;356        //
;;;357        // Get pointer to the boot sector
;;;358        //
;;;359        if(pBoot->ext.sExt16.ui16Sig != 0xAA55)
;;;360        {
;;;361            return(1);
;;;362        }
;;;363    
;;;364        //
;;;365        // Verify the sector size is 512.  We can't deal with anything else
;;;366        //
;;;367        if(pBoot->ui16BytesPerSector != 512)
;;;368        {
;;;369            return(1);
;;;370        }
;;;371    
;;;372        //
;;;373        // Extract some info from the boot record
;;;374        //
;;;375        sPartInfo.ui16SectorsPerCluster = pBoot->ui8SectorsPerCluster;
;;;376        sPartInfo.ui16MaxRootEntries = pBoot->ui16NumRootEntries;
;;;377    
;;;378        //
;;;379        // Decide if we are dealing with FAT16 or FAT32.
;;;380        // If number of root entries is 0, that suggests FAT32
;;;381        //
;;;382        if(sPartInfo.ui16MaxRootEntries == 0)
;;;383        {
;;;384            //
;;;385            // Confirm FAT 32 signature in the expected place
;;;386            //
;;;387            if(!strncmp(pBoot->ext.sExt32.pcFsType, "FAT32   ", 8))
;;;388            {
;;;389                sPartInfo.ui32Type = 32;
;;;390            }
;;;391            else
;;;392            {
;;;393                return(1);
;;;394            }
;;;395        }
;;;396        //
;;;397        // Root entries is non-zero, suggests FAT16
;;;398        //
;;;399        else
;;;400        {
;;;401            //
;;;402            // Confirm FAT16 signature
;;;403            //
;;;404            if(!strncmp(pBoot->ext.sExt16.pcFsType, "FAT16   ", 8))
;;;405            {
;;;406                sPartInfo.ui32Type = 16;
;;;407            }
;;;408            else
;;;409            {
;;;410                return(1);
;;;411            }
;;;412        }
;;;413    
;;;414        //
;;;415        // Find the beginning of the FAT, in absolute sectors
;;;416        //
;;;417        sPartInfo.ui32FirstFATSector = sPartInfo.ui32FirstSector +
;;;418                                     pBoot->ui16ReservedSectors;
;;;419    
;;;420        //
;;;421        // Find the end of the FAT in absolute sectors.  FAT16 and 32
;;;422        // are handled differently.
;;;423        //
;;;424        sPartInfo.ui32SectorsPerFAT = (sPartInfo.ui32Type == 16) ?
;;;425                                    pBoot->ui16SectorsPerFAT :
;;;426                                    pBoot->ext.sExt32.ui32SectorsPerFAT;
;;;427        sPartInfo.ui32LastFATSector = sPartInfo.ui32FirstFATSector +
;;;428                                    sPartInfo.ui32SectorsPerFAT - 1;
;;;429    
;;;430        //
;;;431        // Find the start of the root directory and the data area.
;;;432        // For FAT16, the root will be stored as an absolute sector number
;;;433        // For FAT32, the root will be stored as the starting cluster of the root
;;;434        // The data area start is the absolute first sector of the data area.
;;;435        //
;;;436        if(sPartInfo.ui32Type == 16)
;;;437        {
;;;438            sPartInfo.ui32StartRootDir = sPartInfo.ui32FirstFATSector +
;;;439                                       (sPartInfo.ui32SectorsPerFAT *
;;;440                                        pBoot->ui8NumFATs);
;;;441            sPartInfo.ui32FirstDataSector = sPartInfo.ui32StartRootDir +
;;;442                                          (sPartInfo.ui16MaxRootEntries / 16);
;;;443        }
;;;444        else
;;;445        {
;;;446            sPartInfo.ui32StartRootDir = pBoot->ext.sExt32.ui32RootCluster;
;;;447            sPartInfo.ui32FirstDataSector = sPartInfo.ui32FirstFATSector +
;;;448                                (sPartInfo.ui32SectorsPerFAT * pBoot->ui8NumFATs);
;;;449        }
;;;450    
;;;451        //
;;;452        // At this point the file system has been initialized, so return
;;;453        // success to the caller.
;;;454        //
;;;455        return(0);
;;;456    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L1.26|
00001a  462e              MOV      r6,r5                 ;304
00001c  f8b601fe          LDRH     r0,[r6,#0x1fe]        ;305
000020  f5a0412a          SUB      r1,r0,#0xaa00         ;305
000024  3955              SUBS     r1,r1,#0x55           ;305
000026  d001              BEQ      |L1.44|
000028  2001              MOVS     r0,#1                 ;307
00002a  e7f4              B        |L1.22|
                  |L1.44|
00002c  462c              MOV      r4,r5                 ;313
00002e  2203              MOVS     r2,#3                 ;314
000030  a1b9              ADR      r1,|L1.792|
000032  f1040036          ADD      r0,r4,#0x36           ;314
000036  f7fffffe          BL       strncmp
00003a  b1a0              CBZ      r0,|L1.102|
00003c  2205              MOVS     r2,#5                 ;315
00003e  a1b7              ADR      r1,|L1.796|
000040  f1040052          ADD      r0,r4,#0x52           ;315
000044  f7fffffe          BL       strncmp
000048  b168              CBZ      r0,|L1.102|
00004a  f50677df          ADD      r7,r6,#0x1be          ;320
00004e  68b8              LDR      r0,[r7,#8]            ;329
000050  49b4              LDR      r1,|L1.804|
000052  6008              STR      r0,[r1,#0]            ;329  ; sPartInfo
000054  68f8              LDR      r0,[r7,#0xc]          ;330
000056  6048              STR      r0,[r1,#4]            ;330  ; sPartInfo
000058  6808              LDR      r0,[r1,#0]            ;335  ; sPartInfo
00005a  4629              MOV      r1,r5                 ;335
00005c  f7fffffe          BL       SimpleFsReadMediaSector
000060  b170              CBZ      r0,|L1.128|
000062  2001              MOVS     r0,#1                 ;337
000064  e7d7              B        |L1.22|
                  |L1.102|
000066  2000              MOVS     r0,#0                 ;345
000068  49ae              LDR      r1,|L1.804|
00006a  6008              STR      r0,[r1,#0]            ;345  ; sPartInfo
00006c  f8b40013          LDRH     r0,[r4,#0x13]         ;346
000070  b910              CBNZ     r0,|L1.120|
000072  6a20              LDR      r0,[r4,#0x20]         ;348
000074  6048              STR      r0,[r1,#4]            ;348  ; sPartInfo
000076  e003              B        |L1.128|
                  |L1.120|
000078  f8b40013          LDRH     r0,[r4,#0x13]         ;352
00007c  49a9              LDR      r1,|L1.804|
00007e  6048              STR      r0,[r1,#4]            ;352  ; sPartInfo
                  |L1.128|
000080  f8b401fe          LDRH     r0,[r4,#0x1fe]        ;359
000084  f5a0412a          SUB      r1,r0,#0xaa00         ;359
000088  3955              SUBS     r1,r1,#0x55           ;359
00008a  d001              BEQ      |L1.144|
00008c  2001              MOVS     r0,#1                 ;361
00008e  e7c2              B        |L1.22|
                  |L1.144|
000090  f8b4000b          LDRH     r0,[r4,#0xb]          ;367
000094  f5b07f00          CMP      r0,#0x200             ;367
000098  d001              BEQ      |L1.158|
00009a  2001              MOVS     r0,#1                 ;369
00009c  e7bb              B        |L1.22|
                  |L1.158|
00009e  7b60              LDRB     r0,[r4,#0xd]          ;375
0000a0  49a0              LDR      r1,|L1.804|
0000a2  8108              STRH     r0,[r1,#8]            ;375
0000a4  f8b40011          LDRH     r0,[r4,#0x11]         ;376
0000a8  8148              STRH     r0,[r1,#0xa]          ;376
0000aa  4608              MOV      r0,r1                 ;382
0000ac  8940              LDRH     r0,[r0,#0xa]          ;382  ; sPartInfo
0000ae  b960              CBNZ     r0,|L1.202|
0000b0  2208              MOVS     r2,#8                 ;387
0000b2  a19d              ADR      r1,|L1.808|
0000b4  f1040052          ADD      r0,r4,#0x52           ;387
0000b8  f7fffffe          BL       strncmp
0000bc  b918              CBNZ     r0,|L1.198|
0000be  2020              MOVS     r0,#0x20              ;389
0000c0  4998              LDR      r1,|L1.804|
0000c2  61c8              STR      r0,[r1,#0x1c]         ;389  ; sPartInfo
0000c4  e00e              B        |L1.228|
                  |L1.198|
0000c6  2001              MOVS     r0,#1                 ;393
0000c8  e7a5              B        |L1.22|
                  |L1.202|
0000ca  2208              MOVS     r2,#8                 ;404
0000cc  a199              ADR      r1,|L1.820|
0000ce  f1040036          ADD      r0,r4,#0x36           ;404
0000d2  f7fffffe          BL       strncmp
0000d6  b918              CBNZ     r0,|L1.224|
0000d8  2010              MOVS     r0,#0x10              ;406
0000da  4992              LDR      r1,|L1.804|
0000dc  61c8              STR      r0,[r1,#0x1c]         ;406  ; sPartInfo
0000de  e001              B        |L1.228|
                  |L1.224|
0000e0  2001              MOVS     r0,#1                 ;410
0000e2  e798              B        |L1.22|
                  |L1.228|
0000e4  488f              LDR      r0,|L1.804|
0000e6  6800              LDR      r0,[r0,#0]            ;417  ; sPartInfo
0000e8  89e1              LDRH     r1,[r4,#0xe]          ;417
0000ea  4408              ADD      r0,r0,r1              ;417
0000ec  498d              LDR      r1,|L1.804|
0000ee  6108              STR      r0,[r1,#0x10]         ;417  ; sPartInfo
0000f0  4608              MOV      r0,r1                 ;424
0000f2  69c0              LDR      r0,[r0,#0x1c]         ;424  ; sPartInfo
0000f4  2810              CMP      r0,#0x10              ;424
0000f6  d101              BNE      |L1.252|
0000f8  8ae0              LDRH     r0,[r4,#0x16]         ;425
0000fa  e000              B        |L1.254|
                  |L1.252|
0000fc  6a60              LDR      r0,[r4,#0x24]         ;426
                  |L1.254|
0000fe  4989              LDR      r1,|L1.804|
000100  60c8              STR      r0,[r1,#0xc]          ;426  ; sPartInfo
000102  4608              MOV      r0,r1                 ;427
000104  6900              LDR      r0,[r0,#0x10]         ;427  ; sPartInfo
000106  68c9              LDR      r1,[r1,#0xc]          ;427  ; sPartInfo
000108  4408              ADD      r0,r0,r1              ;427
00010a  1e40              SUBS     r0,r0,#1              ;427
00010c  4985              LDR      r1,|L1.804|
00010e  6148              STR      r0,[r1,#0x14]         ;427  ; sPartInfo
000110  4608              MOV      r0,r1                 ;436
000112  69c0              LDR      r0,[r0,#0x1c]         ;436  ; sPartInfo
000114  2810              CMP      r0,#0x10              ;436
000116  d112              BNE      |L1.318|
000118  4608              MOV      r0,r1                 ;438
00011a  6900              LDR      r0,[r0,#0x10]         ;438  ; sPartInfo
00011c  68c9              LDR      r1,[r1,#0xc]          ;438  ; sPartInfo
00011e  7c22              LDRB     r2,[r4,#0x10]         ;438
000120  fb010002          MLA      r0,r1,r2,r0           ;438
000124  497f              LDR      r1,|L1.804|
000126  6208              STR      r0,[r1,#0x20]         ;438  ; sPartInfo
000128  8948              LDRH     r0,[r1,#0xa]          ;441  ; sPartInfo
00012a  17c1              ASRS     r1,r0,#31             ;441
00012c  eb007111          ADD      r1,r0,r1,LSR #28      ;441
000130  4a7c              LDR      r2,|L1.804|
000132  6a12              LDR      r2,[r2,#0x20]         ;441  ; sPartInfo
000134  eb021121          ADD      r1,r2,r1,ASR #4       ;441
000138  4a7a              LDR      r2,|L1.804|
00013a  6191              STR      r1,[r2,#0x18]         ;441  ; sPartInfo
00013c  e00a              B        |L1.340|
                  |L1.318|
00013e  6ae0              LDR      r0,[r4,#0x2c]         ;446
000140  4978              LDR      r1,|L1.804|
000142  6208              STR      r0,[r1,#0x20]         ;446  ; sPartInfo
000144  4608              MOV      r0,r1                 ;447
000146  6900              LDR      r0,[r0,#0x10]         ;447  ; sPartInfo
000148  68c9              LDR      r1,[r1,#0xc]          ;447  ; sPartInfo
00014a  7c22              LDRB     r2,[r4,#0x10]         ;447
00014c  fb010002          MLA      r0,r1,r2,r0           ;447
000150  4974              LDR      r1,|L1.804|
000152  6188              STR      r0,[r1,#0x18]         ;447  ; sPartInfo
                  |L1.340|
000154  2000              MOVS     r0,#0                 ;455
000156  e75e              B        |L1.22|
;;;457    
                          ENDP

                  SimpleFsGetNextCluster PROC
;;;483    static uint32_t
;;;484    SimpleFsGetNextCluster(uint_fast32_t ui32ThisCluster)
000158  e92d47f0          PUSH     {r4-r10,lr}
;;;485    {
00015c  4605              MOV      r5,r0
;;;486        static uint8_t ui8FATCache[512];
;;;487        static uint_fast32_t ui32CachedFATSector = (uint32_t)-1;
;;;488        uint_fast32_t ui32ClustersPerFATSector;
;;;489        uint_fast32_t ui32ClusterIdx;
;;;490        uint_fast32_t ui32FATSector;
;;;491        uint_fast32_t ui32NextCluster;
;;;492        uint_fast32_t ui32MaxCluster;
;;;493    
;;;494        //
;;;495        // Compute the maximum possible reasonable cluster number
;;;496        //
;;;497        ui32MaxCluster = sPartInfo.ui32NumBlocks / sPartInfo.ui16SectorsPerCluster;
00015e  4871              LDR      r0,|L1.804|
000160  6840              LDR      r0,[r0,#4]  ; sPartInfo
000162  4970              LDR      r1,|L1.804|
000164  8909              LDRH     r1,[r1,#8]  ; sPartInfo
000166  fbb0f9f1          UDIV     r9,r0,r1
;;;498    
;;;499        //
;;;500        // Make sure cluster input number is reasonable.  If not then return
;;;501        // 0 indicating error.
;;;502        //
;;;503        if((ui32ThisCluster < 2) || (ui32ThisCluster > ui32MaxCluster))
00016a  2d02              CMP      r5,#2
00016c  d301              BCC      |L1.370|
00016e  454d              CMP      r5,r9
000170  d902              BLS      |L1.376|
                  |L1.370|
;;;504        {
;;;505            return(0);
000172  2000              MOVS     r0,#0
                  |L1.372|
;;;506        }
;;;507    
;;;508        //
;;;509        // Compute the index of the requested cluster within the sector.
;;;510        // Also compute the sector number within the FAT that contains the
;;;511        // entry for the requested cluster.
;;;512        //
;;;513        ui32ClustersPerFATSector = (sPartInfo.ui32Type == 16) ? 256 : 128;
;;;514        ui32ClusterIdx = ui32ThisCluster % ui32ClustersPerFATSector;
;;;515        ui32FATSector = ui32ThisCluster / ui32ClustersPerFATSector;
;;;516    
;;;517        //
;;;518        // Check to see if the FAT sector we need is already cached
;;;519        //
;;;520        if(ui32FATSector != ui32CachedFATSector)
;;;521        {
;;;522            //
;;;523            // FAT sector we need is not cached, so read it in
;;;524            //
;;;525            if(SimpleFsReadMediaSector(sPartInfo.ui32FirstFATSector + ui32FATSector,
;;;526                                     ui8FATCache) != 0)
;;;527            {
;;;528                //
;;;529                // There was an error so mark cache as unavailable and return
;;;530                // an error.
;;;531                //
;;;532                ui32CachedFATSector = (uint32_t)-1;
;;;533                return(0);
;;;534            }
;;;535    
;;;536            //
;;;537            // Remember which FAT sector was just loaded into the cache.
;;;538            //
;;;539            ui32CachedFATSector = ui32FATSector;
;;;540        }
;;;541    
;;;542        //
;;;543        // Now look up the next cluster value from the cached sector, using this
;;;544        // requested cluster as an index. It needs to be indexed as 16 or 32
;;;545        // bit values depending on whether it is FAT16 or 32
;;;546        // If the cluster value means last cluster, then return 0
;;;547        //
;;;548        if(sPartInfo.ui32Type == 16)
;;;549        {
;;;550            ui32NextCluster = ((uint16_t *)ui8FATCache)[ui32ClusterIdx];
;;;551            if(ui32NextCluster >= 0xFFF8)
;;;552            {
;;;553                return(0);
;;;554            }
;;;555        }
;;;556        else
;;;557        {
;;;558            ui32NextCluster = ((uint32_t *)ui8FATCache)[ui32ClusterIdx];
;;;559            if(ui32NextCluster >= 0x0FFFFFF8)
;;;560            {
;;;561                return(0);
;;;562            }
;;;563        }
;;;564    
;;;565        //
;;;566        // Check new cluster value to make sure it is reasonable.  If not then
;;;567        // return 0 to indicate an error.
;;;568        //
;;;569        if((ui32NextCluster >= 2) && (ui32NextCluster <= ui32MaxCluster))
;;;570        {
;;;571            return(ui32NextCluster);
;;;572        }
;;;573        else
;;;574        {
;;;575            return(0);
;;;576        }
;;;577    }
000174  e8bd87f0          POP      {r4-r10,pc}
                  |L1.376|
000178  486a              LDR      r0,|L1.804|
00017a  69c0              LDR      r0,[r0,#0x1c]         ;513  ; sPartInfo
00017c  2810              CMP      r0,#0x10              ;513
00017e  d101              BNE      |L1.388|
000180  0100              LSLS     r0,r0,#4              ;513
000182  e000              B        |L1.390|
                  |L1.388|
000184  2080              MOVS     r0,#0x80              ;513
                  |L1.390|
000186  4680              MOV      r8,r0                 ;513
000188  fbb5f0f8          UDIV     r0,r5,r8              ;514
00018c  fb085710          MLS      r7,r8,r0,r5           ;514
000190  fbb5f6f8          UDIV     r6,r5,r8              ;515
000194  486a              LDR      r0,|L1.832|
000196  6800              LDR      r0,[r0,#0]            ;520  ; ui32CachedFATSector
000198  4286              CMP      r6,r0                 ;520
00019a  d00e              BEQ      |L1.442|
00019c  4961              LDR      r1,|L1.804|
00019e  6909              LDR      r1,[r1,#0x10]         ;525  ; sPartInfo
0001a0  1988              ADDS     r0,r1,r6              ;525
0001a2  4968              LDR      r1,|L1.836|
0001a4  f7fffffe          BL       SimpleFsReadMediaSector
0001a8  b128              CBZ      r0,|L1.438|
0001aa  f04f30ff          MOV      r0,#0xffffffff        ;532
0001ae  4964              LDR      r1,|L1.832|
0001b0  6008              STR      r0,[r1,#0]            ;532  ; ui32CachedFATSector
0001b2  2000              MOVS     r0,#0                 ;533
0001b4  e7de              B        |L1.372|
                  |L1.438|
0001b6  4862              LDR      r0,|L1.832|
0001b8  6006              STR      r6,[r0,#0]            ;539  ; ui32CachedFATSector
                  |L1.442|
0001ba  485a              LDR      r0,|L1.804|
0001bc  69c0              LDR      r0,[r0,#0x1c]         ;548  ; sPartInfo
0001be  2810              CMP      r0,#0x10              ;548
0001c0  d108              BNE      |L1.468|
0001c2  4860              LDR      r0,|L1.836|
0001c4  f8304017          LDRH     r4,[r0,r7,LSL #1]     ;550
0001c8  f64f70f8          MOV      r0,#0xfff8            ;551
0001cc  4284              CMP      r4,r0                 ;551
0001ce  d309              BCC      |L1.484|
0001d0  2000              MOVS     r0,#0                 ;553
0001d2  e7cf              B        |L1.372|
                  |L1.468|
0001d4  485b              LDR      r0,|L1.836|
0001d6  f8504027          LDR      r4,[r0,r7,LSL #2]     ;558
0001da  485b              LDR      r0,|L1.840|
0001dc  4284              CMP      r4,r0                 ;559
0001de  d301              BCC      |L1.484|
0001e0  2000              MOVS     r0,#0                 ;561
0001e2  e7c7              B        |L1.372|
                  |L1.484|
0001e4  2c02              CMP      r4,#2                 ;569
0001e6  d303              BCC      |L1.496|
0001e8  454c              CMP      r4,r9                 ;569
0001ea  d801              BHI      |L1.496|
0001ec  4620              MOV      r0,r4                 ;571
0001ee  e7c1              B        |L1.372|
                  |L1.496|
0001f0  2000              MOVS     r0,#0                 ;575
0001f2  e7bf              B        |L1.372|
;;;578    
                          ENDP

                  SimpleFsGetNextFileSector PROC
;;;613    uint32_t
;;;614    SimpleFsGetNextFileSector(uint_fast32_t ui32StartCluster)
0001f4  b570              PUSH     {r4-r6,lr}
;;;615    {
0001f6  4604              MOV      r4,r0
;;;616        static uint_fast32_t ui32WorkingCluster = 0;
;;;617        static uint_fast32_t ui32WorkingSector;
;;;618        uint_fast32_t ui32ReadSector;
;;;619    
;;;620        //
;;;621        // If user specified starting cluster, then init the working cluster
;;;622        // and sector values
;;;623        //
;;;624        if(ui32StartCluster)
0001f8  b12c              CBZ      r4,|L1.518|
;;;625        {
;;;626            ui32WorkingCluster = ui32StartCluster;
0001fa  4854              LDR      r0,|L1.844|
0001fc  6004              STR      r4,[r0,#0]  ; ui32WorkingCluster
;;;627            ui32WorkingSector = 0;
0001fe  2000              MOVS     r0,#0
000200  4953              LDR      r1,|L1.848|
000202  6008              STR      r0,[r1,#0]  ; ui32WorkingSector
                  |L1.516|
;;;628            return(0);
;;;629        }
;;;630    
;;;631        //
;;;632        // Otherwise, make sure there is a valid working cluster already
;;;633        //
;;;634        else if(ui32WorkingCluster == 0)
;;;635        {
;;;636            return(0);
;;;637        }
;;;638    
;;;639        //
;;;640        // If the current working sector is the same as sectors per cluster,
;;;641        // then that means that the next cluster needs to be loaded.
;;;642        //
;;;643        if(ui32WorkingSector == sPartInfo.ui16SectorsPerCluster)
;;;644        {
;;;645            //
;;;646            // Get the next cluster in the chain for this file.
;;;647            //
;;;648            ui32WorkingCluster = SimpleFsGetNextCluster(ui32WorkingCluster);
;;;649    
;;;650            //
;;;651            // If the next cluster is valid, then reset the working sector
;;;652            //
;;;653            if(ui32WorkingCluster)
;;;654            {
;;;655                ui32WorkingSector = 0;
;;;656            }
;;;657    
;;;658            //
;;;659            // Next cluster is not valid, or this was the end of the chain.
;;;660            // Clear the working cluster and return an indication that no new
;;;661            // sector data was loaded.
;;;662            //
;;;663            else
;;;664            {
;;;665                ui32WorkingCluster = 0;
;;;666                return(0);
;;;667            }
;;;668        }
;;;669    
;;;670        //
;;;671        // Calculate the sector to read from.  It is the sector of the start
;;;672        // of the working cluster, plus the working sector (the sector within
;;;673        // the cluster), plus the offset to the start of the data area.
;;;674        // Note that the cluster needs to be reduced by 2 in order to index
;;;675        // properly into the data area.  That is a feature of FAT file system.
;;;676        //
;;;677        ui32ReadSector = (ui32WorkingCluster - 2) * sPartInfo.ui16SectorsPerCluster;
;;;678        ui32ReadSector += ui32WorkingSector;
;;;679        ui32ReadSector += sPartInfo.ui32FirstDataSector;
;;;680    
;;;681        //
;;;682        // Attempt to read the next sector from the cluster.  If not successful,
;;;683        // then clear the working cluster and return a non-success indication.
;;;684        //
;;;685        if(SimpleFsReadMediaSector(ui32ReadSector, g_pui8SectorBuf) != 0)
;;;686        {
;;;687            ui32WorkingCluster = 0;
;;;688            return(0);
;;;689        }
;;;690        else
;;;691        {
;;;692            //
;;;693            // Read was successful.  Increment to the next sector of the cluster
;;;694            // and return a success indication.
;;;695            //
;;;696            ui32WorkingSector++;
;;;697            return(1);
;;;698        }
;;;699    }
000204  bd70              POP      {r4-r6,pc}
                  |L1.518|
000206  4851              LDR      r0,|L1.844|
000208  6800              LDR      r0,[r0,#0]            ;634  ; ui32WorkingCluster
00020a  b908              CBNZ     r0,|L1.528|
00020c  2000              MOVS     r0,#0                 ;636
00020e  e7f9              B        |L1.516|
                  |L1.528|
000210  4844              LDR      r0,|L1.804|
000212  8900              LDRH     r0,[r0,#8]            ;643  ; sPartInfo
000214  494e              LDR      r1,|L1.848|
000216  6809              LDR      r1,[r1,#0]            ;643  ; ui32WorkingSector
000218  4288              CMP      r0,r1                 ;643
00021a  d110              BNE      |L1.574|
00021c  484b              LDR      r0,|L1.844|
00021e  6800              LDR      r0,[r0,#0]            ;648  ; ui32WorkingCluster
000220  f7fffffe          BL       SimpleFsGetNextCluster
000224  4949              LDR      r1,|L1.844|
000226  6008              STR      r0,[r1,#0]            ;648  ; ui32WorkingCluster
000228  4608              MOV      r0,r1                 ;653
00022a  6800              LDR      r0,[r0,#0]            ;653  ; ui32WorkingCluster
00022c  b118              CBZ      r0,|L1.566|
00022e  2000              MOVS     r0,#0                 ;655
000230  4947              LDR      r1,|L1.848|
000232  6008              STR      r0,[r1,#0]            ;655  ; ui32WorkingSector
000234  e003              B        |L1.574|
                  |L1.566|
000236  2000              MOVS     r0,#0                 ;665
000238  4944              LDR      r1,|L1.844|
00023a  6008              STR      r0,[r1,#0]            ;665  ; ui32WorkingCluster
00023c  e7e2              B        |L1.516|
                  |L1.574|
00023e  4843              LDR      r0,|L1.844|
000240  6800              LDR      r0,[r0,#0]            ;677  ; ui32WorkingCluster
000242  1e80              SUBS     r0,r0,#2              ;677
000244  4937              LDR      r1,|L1.804|
000246  8909              LDRH     r1,[r1,#8]            ;677  ; sPartInfo
000248  fb00f501          MUL      r5,r0,r1              ;677
00024c  4840              LDR      r0,|L1.848|
00024e  6800              LDR      r0,[r0,#0]            ;678  ; ui32WorkingSector
000250  4405              ADD      r5,r5,r0              ;678
000252  4834              LDR      r0,|L1.804|
000254  6980              LDR      r0,[r0,#0x18]         ;679  ; sPartInfo
000256  4405              ADD      r5,r5,r0              ;679
000258  482e              LDR      r0,|L1.788|
00025a  6801              LDR      r1,[r0,#0]            ;685  ; g_pui8SectorBuf
00025c  4628              MOV      r0,r5                 ;685
00025e  f7fffffe          BL       SimpleFsReadMediaSector
000262  b118              CBZ      r0,|L1.620|
000264  2000              MOVS     r0,#0                 ;687
000266  4939              LDR      r1,|L1.844|
000268  6008              STR      r0,[r1,#0]            ;687  ; ui32WorkingCluster
00026a  e7cb              B        |L1.516|
                  |L1.620|
00026c  4838              LDR      r0,|L1.848|
00026e  6800              LDR      r0,[r0,#0]            ;696  ; ui32WorkingSector
000270  1c40              ADDS     r0,r0,#1              ;696
000272  4937              LDR      r1,|L1.848|
000274  6008              STR      r0,[r1,#0]            ;696  ; ui32WorkingSector
000276  2001              MOVS     r0,#1                 ;697
000278  e7c4              B        |L1.516|
;;;700    
                          ENDP

                  SimpleFsOpen PROC
;;;731    uint32_t
;;;732    SimpleFsOpen(char *pcName83)
00027a  e92d41f0          PUSH     {r4-r8,lr}
;;;733    {
00027e  4606              MOV      r6,r0
;;;734        tDirEntry *pDirEntry;
;;;735        uint_fast32_t ui32DirSector;
;;;736        uint_fast32_t ui32FirstCluster;
;;;737    
;;;738        //
;;;739        // Find starting root dir sector, only used for FAT16
;;;740        // If FAT32 then this is the first cluster of root dir
;;;741        //
;;;742        ui32DirSector = sPartInfo.ui32StartRootDir;
000280  4828              LDR      r0,|L1.804|
000282  6a07              LDR      r7,[r0,#0x20]  ; sPartInfo
;;;743    
;;;744        //
;;;745        // For FAT32, root dir is like a file, so init a file read of the root dir
;;;746        //
;;;747        if(sPartInfo.ui32Type == 32)
000284  69c0              LDR      r0,[r0,#0x1c]  ; sPartInfo
000286  2820              CMP      r0,#0x20
000288  d102              BNE      |L1.656|
;;;748        {
;;;749            SimpleFsGetNextFileSector(ui32DirSector);
00028a  4638              MOV      r0,r7
00028c  f7fffffe          BL       SimpleFsGetNextFileSector
                  |L1.656|
;;;750        }
;;;751    
;;;752        //
;;;753        // Search the root directory entry for the firmware file
;;;754        //
;;;755        while(1)
000290  e03f              B        |L1.786|
                  |L1.658|
;;;756        {
;;;757            //
;;;758            // Read in a directory block.
;;;759            //
;;;760            if(sPartInfo.ui32Type == 16)
000292  4824              LDR      r0,|L1.804|
000294  69c0              LDR      r0,[r0,#0x1c]  ; sPartInfo
000296  2810              CMP      r0,#0x10
000298  d108              BNE      |L1.684|
;;;761            {
;;;762                //
;;;763                // For FAT16, read in a sector of the root directory
;;;764                //
;;;765                if(SimpleFsReadMediaSector(ui32DirSector, g_pui8SectorBuf))
00029a  481e              LDR      r0,|L1.788|
00029c  6801              LDR      r1,[r0,#0]  ; g_pui8SectorBuf
00029e  4638              MOV      r0,r7
0002a0  f7fffffe          BL       SimpleFsReadMediaSector
0002a4  b140              CBZ      r0,|L1.696|
;;;766                {
;;;767                    return(0);
0002a6  2000              MOVS     r0,#0
                  |L1.680|
;;;768                }
;;;769            }
;;;770            else
;;;771            {
;;;772                //
;;;773                // For FAT32, the root directory is treated like a file.
;;;774                // The root directory sector will be loaded into the sector buf
;;;775                //
;;;776                if(SimpleFsGetNextFileSector(0) == 0)
;;;777                {
;;;778                    return(0);
;;;779                }
;;;780            }
;;;781    
;;;782            //
;;;783            // Initialize the directory entry pointer to the first entry of
;;;784            // this sector.
;;;785            //
;;;786            pDirEntry = (tDirEntry *)g_pui8SectorBuf;
;;;787    
;;;788            //
;;;789            // Iterate through all the directory entries in this sector
;;;790            //
;;;791            while((uint8_t *)pDirEntry < &g_pui8SectorBuf[512])
;;;792            {
;;;793                //
;;;794                // If the 8.3 filename of this entry matches the firmware
;;;795                // file name, then we have a match, so return a pointer to
;;;796                // this entry.
;;;797                //
;;;798                if(!strncmp(pDirEntry->pcFileName, pcName83, 11))
;;;799                {
;;;800                    //
;;;801                    // Compute the starting cluster of the file
;;;802                    //
;;;803                    ui32FirstCluster = pDirEntry->ui16Cluster;
;;;804                    if(sPartInfo.ui32Type == 32)
;;;805                    {
;;;806                        //
;;;807                        // For FAT32, add in the upper word of the
;;;808                        // starting cluster number
;;;809                        //
;;;810                        ui32FirstCluster += pDirEntry->ui16ClusterHi << 16;
;;;811                    }
;;;812    
;;;813                    //
;;;814                    // Initialize the start of the file
;;;815                    //
;;;816                    SimpleFsGetNextFileSector(ui32FirstCluster);
;;;817                    return(pDirEntry->ui32FileSize);
;;;818                }
;;;819    
;;;820                //
;;;821                // Advance to the next entry in this sector.
;;;822                //
;;;823                pDirEntry++;
;;;824            }
;;;825    
;;;826            //
;;;827            // Need to get the next sector in the directory.  Handled
;;;828            // differently depending on if this is FAT16 or 32
;;;829            //
;;;830            if(sPartInfo.ui32Type == 16)
;;;831            {
;;;832                //
;;;833                // FAT16: advance sectors as int32_t as there are more possible
;;;834                // entries.
;;;835                //
;;;836                sPartInfo.ui16MaxRootEntries -= 512 / 32;
;;;837                if(sPartInfo.ui16MaxRootEntries)
;;;838                {
;;;839                    ui32DirSector++;
;;;840                }
;;;841                else
;;;842                {
;;;843                    //
;;;844                    // Ran out of directory entries and didn't find the file,
;;;845                    // so return a null.
;;;846                    //
;;;847                    return(0);
;;;848                }
;;;849            }
;;;850            else
;;;851            {
;;;852                //
;;;853                // FAT32: there is nothing to compute here.  The next root
;;;854                // dir sector will be fetched at the top of the loop
;;;855                //
;;;856            }
;;;857        }
;;;858    }
0002a8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.684|
0002ac  2000              MOVS     r0,#0                 ;776
0002ae  f7fffffe          BL       SimpleFsGetNextFileSector
0002b2  b908              CBNZ     r0,|L1.696|
0002b4  2000              MOVS     r0,#0                 ;778
0002b6  e7f7              B        |L1.680|
                  |L1.696|
0002b8  4816              LDR      r0,|L1.788|
0002ba  6804              LDR      r4,[r0,#0]            ;786  ; g_pui8SectorBuf
0002bc  e013              B        |L1.742|
                  |L1.702|
0002be  220b              MOVS     r2,#0xb               ;798
0002c0  4631              MOV      r1,r6                 ;798
0002c2  4620              MOV      r0,r4                 ;798
0002c4  f7fffffe          BL       strncmp
0002c8  b960              CBNZ     r0,|L1.740|
0002ca  8b65              LDRH     r5,[r4,#0x1a]         ;803
0002cc  4815              LDR      r0,|L1.804|
0002ce  69c0              LDR      r0,[r0,#0x1c]         ;804  ; sPartInfo
0002d0  2820              CMP      r0,#0x20              ;804
0002d2  d102              BNE      |L1.730|
0002d4  8aa0              LDRH     r0,[r4,#0x14]         ;810
0002d6  eb054500          ADD      r5,r5,r0,LSL #16      ;810
                  |L1.730|
0002da  4628              MOV      r0,r5                 ;816
0002dc  f7fffffe          BL       SimpleFsGetNextFileSector
0002e0  69e0              LDR      r0,[r4,#0x1c]         ;817
0002e2  e7e1              B        |L1.680|
                  |L1.740|
0002e4  3420              ADDS     r4,r4,#0x20           ;823
                  |L1.742|
0002e6  480b              LDR      r0,|L1.788|
0002e8  6800              LDR      r0,[r0,#0]            ;791  ; g_pui8SectorBuf
0002ea  f5007000          ADD      r0,r0,#0x200          ;791
0002ee  4284              CMP      r4,r0                 ;791
0002f0  d3e5              BCC      |L1.702|
0002f2  480c              LDR      r0,|L1.804|
0002f4  69c0              LDR      r0,[r0,#0x1c]         ;830  ; sPartInfo
0002f6  2810              CMP      r0,#0x10              ;830
0002f8  d10b              BNE      |L1.786|
0002fa  480a              LDR      r0,|L1.804|
0002fc  8940              LDRH     r0,[r0,#0xa]          ;836  ; sPartInfo
0002fe  3810              SUBS     r0,r0,#0x10           ;836
000300  4908              LDR      r1,|L1.804|
000302  8148              STRH     r0,[r1,#0xa]          ;836
000304  4608              MOV      r0,r1                 ;837
000306  8940              LDRH     r0,[r0,#0xa]          ;837  ; sPartInfo
000308  b108              CBZ      r0,|L1.782|
00030a  1c7f              ADDS     r7,r7,#1              ;839
00030c  e001              B        |L1.786|
                  |L1.782|
00030e  2000              MOVS     r0,#0                 ;847
000310  e7ca              B        |L1.680|
                  |L1.786|
000312  e7be              B        |L1.658|
;;;859    
                          ENDP

                  |L1.788|
                          DCD      g_pui8SectorBuf
                  |L1.792|
000318  46415400          DCB      "FAT",0
                  |L1.796|
00031c  46415433          DCB      "FAT32",0
000320  3200    
000322  00                DCB      0
000323  00                DCB      0
                  |L1.804|
                          DCD      sPartInfo
                  |L1.808|
000328  46415433          DCB      "FAT32   ",0
00032c  32202020
000330  00      
000331  00                DCB      0
000332  00                DCB      0
000333  00                DCB      0
                  |L1.820|
000334  46415431          DCB      "FAT16   ",0
000338  36202020
00033c  00      
00033d  00                DCB      0
00033e  00                DCB      0
00033f  00                DCB      0
                  |L1.832|
                          DCD      ui32CachedFATSector
                  |L1.836|
                          DCD      ui8FATCache
                  |L1.840|
                          DCD      0x0ffffff8
                  |L1.844|
                          DCD      ui32WorkingCluster
                  |L1.848|
                          DCD      ui32WorkingSector

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ui8FATCache
                          %        512
                  sPartInfo
                          %        36

                          AREA ||.data||, DATA, ALIGN=2

                  ui32CachedFATSector
                          DCD      0xffffffff
                  ui32WorkingCluster
                          DCD      0x00000000
                  ui32WorkingSector
                          DCD      0x00000000
                  g_pui8SectorBuf
                          DCD      0x00000000
